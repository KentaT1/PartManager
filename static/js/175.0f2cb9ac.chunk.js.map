{"version":3,"file":"static/js/175.0f2cb9ac.chunk.js","mappings":"qGAiGOA,eAAeC,EAAsBC,GAC1C,IACE,MAAMC,EAAW,IAAIC,SAASF,GAU9B,GAAc,SAPAG,OAAOC,aACnBH,EAASI,SAAS,GAClBJ,EAASI,SAAS,GAClBJ,EAASI,SAAS,GAClBJ,EAASI,SAAS,IAIlB,MAAM,IAAIC,MAAM,kCAKlB,MAAMC,EAAa,GAEnB,IAAK,IAAIC,EAAI,GAAIA,EAAIP,EAASQ,WAAa,EAAGD,GAAK,EACjD,IACE,MAAME,EAAQT,EAASU,UAAUH,GAAG,GAEpC,GAAIE,EAAQ,GAAKA,EAAQ,KAAY,EAGjBF,GAAK,EAAIP,EAASU,UAAUH,EAAI,GAAG,GAAQ,GAC7C,KAASE,EAAQ,KAC/BH,EAAWK,KAAKF,EAEpB,CACF,CAAE,MAAOG,GACP,QACF,CAGF,GAAIN,EAAWO,OAAS,EACtB,MAAM,IAAIR,MAAM,gDAIlB,MAAMS,EAAmBR,EAAWS,KAAK,CAACC,EAAGC,IAAMD,EAAIC,GACjDC,EAAiBJ,EAAiB,GAClCK,EAAgBL,EAAiBA,EAAiBD,OAAS,GAI3DO,GADsBD,EAAgBD,GACF,IAE1C,OAAOG,KAAKC,IAAI,EAAGF,EACrB,CAAE,MAAOG,GAEP,MADAC,QAAQD,MAAM,0CAA2CA,GACnDA,CACR,CACF,C","sources":["utils/logParser.js"],"sourcesContent":["/**\r\n * WPILib Data Log Parser\r\n * Parses .wpilog files to extract elapsed time in minutes\r\n * Based on WPILib Data Log File Format Specification\r\n * Reference: https://docs.wpilib.org/en/stable/docs/software/telemetry/datalog.html\r\n */\r\n\r\n/**\r\n * Parse a WPILib log file and calculate elapsed time in minutes\r\n * @param {ArrayBuffer} fileData - The binary log file data\r\n * @returns {Promise<number>} - Elapsed time in minutes\r\n */\r\nexport async function parseWpilogFile(fileData) {\r\n  try {\r\n    const dataView = new DataView(fileData);\r\n    let position = 0;\r\n    \r\n    // WPILib log file format:\r\n    // - Header: 12 bytes (magic number + version)\r\n    // - Records: variable length with timestamps\r\n    \r\n    // Check magic number (first 4 bytes should be \"WPIL\")\r\n    const magic = String.fromCharCode(\r\n      dataView.getUint8(0),\r\n      dataView.getUint8(1),\r\n      dataView.getUint8(2),\r\n      dataView.getUint8(3)\r\n    );\r\n    \r\n    if (magic !== 'WPIL') {\r\n      throw new Error('Invalid WPILib log file format');\r\n    }\r\n    \r\n    // Skip header (12 bytes: 4 byte magic + 4 byte version + 4 byte extra header)\r\n    position = 12;\r\n    \r\n    let firstTimestamp = null;\r\n    let lastTimestamp = null;\r\n    \r\n    // Parse records\r\n    while (position < dataView.byteLength - 8) {\r\n      try {\r\n        // Record format: 4 byte entry ID + 4 byte timestamp + data\r\n        // eslint-disable-next-line no-unused-vars\r\n        const entryId = dataView.getUint32(position, true); // little-endian\r\n        const timestamp = dataView.getUint32(position + 4, true); // microseconds\r\n        \r\n        // Check if this is a valid timestamp (reasonable range)\r\n        // Timestamps are in microseconds since FPGA start\r\n        if (timestamp > 0 && timestamp < 1e12) {\r\n          if (firstTimestamp === null) {\r\n            firstTimestamp = timestamp;\r\n          }\r\n          lastTimestamp = timestamp;\r\n        }\r\n        \r\n        // Move to next record (minimum record size is 8 bytes)\r\n        // We'll skip ahead conservatively\r\n        position += 8;\r\n        \r\n        // Try to find next record by looking for reasonable entry IDs\r\n        // This is a simplified parser - a full parser would need to handle\r\n        // all record types properly\r\n        if (position < dataView.byteLength - 8) {\r\n          const nextEntryId = dataView.getUint32(position, true);\r\n          // If next entry ID looks invalid, skip ahead\r\n          if (nextEntryId > 1000000) {\r\n            position += 4;\r\n          }\r\n        }\r\n      } catch (e) {\r\n        // If we hit an error, try to continue\r\n        position += 4;\r\n        if (position >= dataView.byteLength) break;\r\n      }\r\n    }\r\n    \r\n    if (firstTimestamp === null || lastTimestamp === null) {\r\n      throw new Error('Could not extract timestamps from log file');\r\n    }\r\n    \r\n    // Calculate elapsed time in minutes\r\n    // Timestamps are in microseconds\r\n    const elapsedMicroseconds = lastTimestamp - firstTimestamp;\r\n    const elapsedMinutes = elapsedMicroseconds / (1000000 * 60);\r\n    \r\n    return Math.max(0, elapsedMinutes);\r\n  } catch (error) {\r\n    console.error('Error parsing log file:', error);\r\n    throw new Error(`Failed to parse log file: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Alternative parser using a more robust approach\r\n * Tries to find timestamp records more reliably\r\n */\r\nexport async function parseWpilogFileRobust(fileData) {\r\n  try {\r\n    const dataView = new DataView(fileData);\r\n    \r\n    // Check magic number\r\n    const magic = String.fromCharCode(\r\n      dataView.getUint8(0),\r\n      dataView.getUint8(1),\r\n      dataView.getUint8(2),\r\n      dataView.getUint8(3)\r\n    );\r\n    \r\n    if (magic !== 'WPIL') {\r\n      throw new Error('Invalid WPILib log file format');\r\n    }\r\n    \r\n    // Scan through the file looking for timestamp patterns\r\n    // Timestamps are typically in the range of microseconds since FPGA start\r\n    const timestamps = [];\r\n    \r\n    for (let i = 12; i < dataView.byteLength - 8; i += 4) {\r\n      try {\r\n        const value = dataView.getUint32(i, true);\r\n        // Reasonable timestamp range: 0 to 1 hour in microseconds\r\n        if (value > 0 && value < 3600000000) {\r\n          // Check if this might be a timestamp by looking at context\r\n          // Timestamps often appear in pairs (entry ID + timestamp)\r\n          const prevValue = i >= 4 ? dataView.getUint32(i - 4, true) : 0;\r\n          if (prevValue < 10000 && value > 1000) {\r\n            timestamps.push(value);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        continue;\r\n      }\r\n    }\r\n    \r\n    if (timestamps.length < 2) {\r\n      throw new Error('Could not find enough timestamps in log file');\r\n    }\r\n    \r\n    // Get first and last timestamps\r\n    const sortedTimestamps = timestamps.sort((a, b) => a - b);\r\n    const firstTimestamp = sortedTimestamps[0];\r\n    const lastTimestamp = sortedTimestamps[sortedTimestamps.length - 1];\r\n    \r\n    // Calculate elapsed time in minutes\r\n    const elapsedMicroseconds = lastTimestamp - firstTimestamp;\r\n    const elapsedMinutes = elapsedMicroseconds / (1000000 * 60);\r\n    \r\n    return Math.max(0, elapsedMinutes);\r\n  } catch (error) {\r\n    console.error('Error parsing log file (robust method):', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n"],"names":["async","parseWpilogFileRobust","fileData","dataView","DataView","String","fromCharCode","getUint8","Error","timestamps","i","byteLength","value","getUint32","push","e","length","sortedTimestamps","sort","a","b","firstTimestamp","lastTimestamp","elapsedMinutes","Math","max","error","console"],"ignoreList":[],"sourceRoot":""}